@ task 1: HEX display drivers

// define any variables/memory space you need here
// your code starts here

//defining my varibales for easier readibility 

.equ OUTPUT_LED, 0xFF200000
//addr led contr
.equ PUSHBUTTON_IN, 0xFF200050
//ADDRE Pb rg
.equ PUSHBUTTON_EDGE, 0xFF20005C
//addr pb edgcap reg
.equ SWITCH_INPUT, 0xFF200040
//addr switch data reg
.equ HEX_DISP, 0xFF200020
//addr hex display


//constant variables 
.equ HEX_NUM,0x00 
.equ HEX0_NUM,0x01
.equ HEX1_NUM,0x02
.equ HEX2_NUM,0x04
.equ HEX3_NUM,0x08
//all in da code
.equ HEX4_NUM,0x10
.equ HEX5_NUM,0x20

.equ HEX1_OFFSET,0x01  
//OFFS for HEX1
.equ HEX2_OFFSET,0x02  
//OFFS for HEX2
.equ HEX3_OFFSET,0x03  
//OFFS for HEX3
.equ HEX4_OFFSET,0x10  
//OFFS for HEX4 //16
.equ HEX5_OFFSET,0x11  
//OFFS for HEX5 (17 in dec)

.equ ERROR_UNDERFLOW, 0xE0  //Err code for underflow
.equ ERROR_OVERFLOW,  0xE1  //Errcode for overflow

.equ HEX0DISP, 0x3F    //7-seg encoding for0
//USEDONCE
.equ ERROR_SYM,  0x71    //7-seg encoding for error E

.equ MAX_VALID_DIGIT, 15 //to make easeir               

.equ FULL_DISPLAY, 0b111111

HEX_TABLE:
    .byte 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07   // 0-7
    .byte 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71   // 8-F
    .byte 0x40, 0, 0, 0  // Encoding for "-" (index 16)
//CK_PTR: .word calculator_stack  //initi SP to  start of the calc stack


.equ HEX_BASE, 0xFF200020   // Define the base address of HEX displays

	
// your code ends here

.global _start
_start:

// test case #1: flood selected segments
test_case_1:
    MOV R0, #0b111111
    BL HEX_clear_ASM    // clear all HEXs
    
    MOV R0, #0b111011
    BL HEX_flood_ASM    // flood HEX 5-3 and HEX 1-0
    
    MOV R0, #0b101010
    BL HEX_clear_ASM    // clear HEX 5, 3, 1

    B end // comment this out to go to test case #2
// end of test case #1

// test case #2: sequential writes to HEXs
test_case_2:
    MOV R0, #0b111111
    BL HEX_clear_ASM    // clear all HEXs
    
    MOV R4, #0x1       
    MOV R5, #7
    
// loop through HEX 0 to 5 and write 7 to C to them
loop_test_case:
    CMP R4, #0x20
    BGT    end      // change this line to 'BGT test_case_3' to go to test case #3
    
    MOV R0, R4
    MOV R1, R5
    BL  HEX_write_ASM
    
    LSL R4, #1
    ADD R5, #1
    B    loop_test_case
// end of test case #2

// test case #3: parallel and overlapping writes to HEXs
test_case_3:
    MOV R0, #0b111111
    BL HEX_clear_ASM    // clear all HEXs
    
    MOV R0, #0b010010
    MOV R1, #0xe
    BL  HEX_write_ASM   // write E to HEX 4, HEX 1
    
    MOV R0, #0b101001
    MOV R1, #0xffffffff
    BL  HEX_write_ASM   // write - sign to HEX 5, HEX 3, HEX 0
	
    MOV R0, #0b001100
    MOV R1, #0xc
    BL  HEX_write_ASM   // write C to HEX 3, HEX 2
    
    MOV R0, #0b000100
    MOV R1, #0x5
    BL  HEX_write_ASM   // write 5 to HEX 2

// end of test case #3

end:
    B     end

// ===================================  drivers  ========================================
	
HEX_clear_ASM:
	// your code starts here

	 PUSH {LR}               
    LDR R1,=HEX_DISP 
	
	

	
	//base addr HEX display reg
    MOV R2,#HEX_NUM           //clear that display 



LOOPED_CLEARED:
    PUSH {R5}//R5 FOR TEMP
    CMP R0,#0//SEE all HEX displays are gone through
    BEQ CLEARED//no more displays need clearing =leave

    AND R5,R0,#HEX0_NUM  //testing if hex0 is selected
    
	
	CMP R5,#0      
	//see result
	
	
    BEQ JUMPHEX0  
	//skips clearing if not set
    STRB R2,[R1]  
	//clears 
JUMPHEX0:
    AND R5,R0,#HEX1_NUM   //check if HEX1 is choosen
	
    CMP R5,#0   //comp w 0 to see if shud be cleared 
    BEQ JUMPHEX1  
	
	//if hex1 not choose, go to next hex check
    STRB R2,[R1,#HEX1_OFFSET]  
	//clearing HEX1 DISP
	
JUMPHEX1:
    AND R5,R0,#HEX2_NUM   //if hex2 selected
    CMP R5, #0      
	//always comp w 0 
    BEQ JUMPHEX2     //ifnot move to next 
    STRB R2,[R1,#HEX2_OFFSET] //clear hex2
JUMPHEX2:
  
  	AND R5,R0,#HEX3_NUM   //if hex3selected
    CMP R5,#0      
	//SEE MORE EFFIEICENT WAY
	
	
	
	
	
	
	
	
    BEQ JUMPHEX3     //jump next 
    STRB R2,[R1,#HEX3_OFFSET]  //clear
JUMPHEX3:
    AND R5,R0,#HEX4_NUM  //if hex4selected
    CMP R5,#0      
	
    BEQ JUMPHEX4   //move to next
	
	
	
	
	
    STRB R2,[R1,#HEX4_OFFSET]  //same
JUMPHEX4:
    AND R5,R0,#HEX5_NUM   //if hex5selected
	
	//anyway to minimzise redudncacy
	//ask TAAA!!!!!!!!!!!!!!11
	
	
	
    CMP R5,#0   //see again 
    BEQ JUMPHEX5         //move to next
    STRB R2,[R1,#HEX5_OFFSET]  
	//clears
JUMPHEX5:

CLEARED:
    POP {R5}                // safety retsory
    POP {LR}                // consistency 
    BX LR                   // back to caller


	
    // your code ends here
	
HEX_flood_ASM:
	// your code starts here
	PUSH {LR}               
    LDR R1,=HEX_BASE       //base address for HEX 
	//refer to above 
    MOV R2,#0x7F           // 7segencoding for 8
	//aka all segments ON
	//see if neeed variable 

loopingFlood: 
    PUSH {R7}               // save temp reg
	//REMEBER TO POP @ END 
    CMP R0,#0              //processing displayes
	//makes sure to check 
    BEQ flood_done          //leave if none are left

    // goes through each hex display
	//if selected turns on
    AND R7,R0,#HEX0_NUM   //is hex0 selected?
    CMP R7,#0
    BEQ NEXTFLOOD0
	
	
    STRB R2,[R1]           //  0x7F to hexo
	//stored in var for simplicity 
NEXTFLOOD0:
    AND R7,R0,#HEX1_NUM   //is hex1 selected?
    CMP R7,#0
    BEQ NEXTFLOOD1
	
	
    STRB R2,[R1,#HEX1_OFFSET]  //write 0x7F to HEX1
	//turns it on
NEXTFLOOD1:
	//CHECK W TA
    AND R7,R0,#HEX2_NUM   //is hex2 selected?
    CMP R7,#0
	//REFER BACK TO 
    BEQ NEXTFLOOD2 //if not skip 
	
	
    STRB R2,[R1, #HEX2_OFFSET]  //write 0x7F to hex2
	//variables to make easier or is it redudncat
NEXTFLOOD2:

    AND R7,R0,#HEX3_NUM   // is hex3 selected?
    CMP R7,#0
    BEQ NEXTFLOOD3
	
	
	
	//skip if not
    STRB R2,[R1,#HEX3_OFFSET]  //  0x7F to hex3
NEXTFLOOD3:
    AND R7, R0,#HEX4_NUM   //is hex4 selected?
    CMP R7,#0
    BEQ NEXTFLOOD4
	
	
    STRB R2,[R1,#HEX4_OFFSET]  //  0x7F to hex4
NEXTFLOOD4:
    AND R7,R0,#HEX5_NUM   //is hex5 selected?
    CMP R7,#0
    BEQ NEXTFLOOD5
	
	
	
    STRB R2,[R1,#HEX5_OFFSET]  //  0x7F to hex5
NEXTFLOOD5:
	//for 
flood_done:
    POP {R7}                // restoration
    POP {LR}                
    BX LR                   // return to caller
//make sure organzised
	
	
    // your code ends here
	
HEX_write_ASM: 
	// your code starts here
	PUSH {R4,LR} 
    //PUSH {R4,R5,LR}          
    LDR R2,=HEX_TABLE 
	

	
	//  address of the 7segm encoding table
	//refer to at the top
	//see if different formats

    //CMP R1, #-1             //check if R1 contains -1 --> -
	CMP R1, #-1
    BNE NUMBER_IN_RANGE
    LDRB R3, [R2, #16]      
    B ANSWER_SET             //jmp to display logic

NUMBER_IN_RANGE://comparing with diff ways for prac
    SUBS R1,R1,#MAX_VALID_DIGIT  //sbtract MAX_VALID_DIGIT, sets flags
    BGT WRONG_DIGIT                
	//if R1 >MAX_VALID_DIGIT, branch
    ADD R1,R1,#MAX_VALID_DIGIT   //restore original R1 before loading
    LDRB R3,[R2,R1]              //load byte from HEX table   
ANSWER_SET:
    LDR R4,=HEX_DISP       //load base addr of HEX displays
	//ADD R4,R4, R0          // Use correct byteoffset addressing
    //STRB R3,[R4,R0,LSL#2]  
	//THISSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	


write_loop:
	PUSH {R5}
    CMP R0,#0              //check if all selected HEX displays are processed
    BEQ NO_WRITE            // if none --> exit

    // Process HEX0
    AND R5,R0,#HEX0_NUM   //perform bitwise AND to check if HEX0 is selected
    CMP R5,#0              
	//shud use varibale???
  
  
  BEQ dontWrite0
    STRB R3,[R4]           
	//  endocded to hex 0
dontWrite0:




    // Process HEX1
    AND R5,R0,#HEX1_NUM   // Perform bitwise AND to check if HEX1 is selected
    CMP R5,#0   
	
	
	
	
	// Compare with zero
    BEQ dontWrite1
    STRB R3,[R4,#HEX1_OFFSET]  // encoded to hex1
dontWrite1:

    //for hex2
    AND R5,R0,#HEX2_NUM   //perform bitwise AND to check if HEX2 is selected
    CMP R5,#0              
	//var??
    BEQ dontWrite2
    STRB R3, [R4,#HEX2_OFFSET]  // encoded to hex2
dontWrite2:
    // Process HEX3
    AND R5,R0,#HEX3_NUM   //perform bitwise AND to check if HEX3 is selected
    CMP R5,#0     
	
	
	
	
	
	//compare with zero
    BEQ dontWrite3
    STRB R3,[R4,#HEX3_OFFSET] 
	// encoded to hex3
dontWrite3:
    // Process HEX4
    AND R5,R0,#HEX4_NUM   //perform bitwise AND to check if HEX4 is selected
    CMP R5, #0              
	//compare w zero
    BEQ dontWrite4
	
	
	
	
	
	
	
    STRB R3, [R4,#HEX4_OFFSET]  // // encoded to hex4
dontWrite4:
    // Process HEX5
    AND R5,R0,#HEX5_NUM   //just redundant atp
	//see another way 
	//ask TA graded on efficiency????????????????????????????????
    CMP R5,#0             
    BEQ dontWrite5
    STRB R3,[R4,#HEX5_OFFSET]  //// encoded to hex5
dontWrite5:
	//anything/?
NO_WRITE:
	POP {R5}
    POP {R4,LR}            // major restore b4 returning
    BX LR                  

WRONG_DIGIT:
	
    B NO_WRITE            //i digit is invalid, do nothing and exit

	
// ===================================  helper functions  ========================================
// you can define any additional subroutines in this area


    // your code ends here
    
